import net.minecraftforge.mcpconfig.tasks.*
import net.neoforged.srgutils.MinecraftVersion

import javax.inject.Inject
import java.nio.file.Files
import java.util.function.BiFunction
import java.util.stream.Collectors

apply plugin: 'java'
apply plugin: 'de.undercouch.download'
apply plugin: 'maven-publish'

group = rootProject.group
version = name

ext {
    MC_VERSION = MinecraftVersion.from(project.name)
    PATH_CACHED_LIBRARIES = PATH_BUILD + '/libraries/'
    PATH_CACHED_VERSION = PATH_BUILD + '/versions/' + project.version + '/'
    PATH_CACHED_VERSION_DATA = PATH_CACHED_VERSION + 'data/'
    
    PATH_INJECT = file('inject')
    PATH_INJECT_TEMPLATE = new File(PATH_INJECT, 'package-info-template.java')
    PATH_NATIVES = file('projects/natives')

    CONFIG = file('config.json').json
    JAVA_TARGET = CONFIG.get('java_target', 8)
    ENCODING = CONFIG.get('encoding', 'UTF-8')
    FERNFLOWER = Utils.readConfig(CONFIG, 'fernflower', [:])        
    MERGETOOL = Utils.readConfig(CONFIG, 'merge', [
        version: 'net.minecraftforge:mergetool:1.1.3:fatjar',
        args: ["--client", "{client}", "--server", "{server}", "--ann", "{version}", "--output", "{output}"]
    ])
    BUNDLE_EXTRACT_JAR = Utils.readConfig(CONFIG, 'bundler_extract_jar', [:])
    BUNDLE_EXTRACT_LIBS = Utils.readConfig(CONFIG, 'bundler_extract_libs', [:])
    TOOLS = [FERNFLOWER, MERGETOOL, BUNDLE_EXTRACT_JAR, BUNDLE_EXTRACT_LIBS].findAll {it?.version != null}
}

abstract class ComponentMaker {
    @Inject
    abstract SoftwareComponentFactory getComponentFactory()
}

java.toolchain.languageVersion = JavaLanguageVersion.of(JAVA_TARGET)

configurations {
    srgutilsJar
    fernflower
    mergetool
    nfrt {
        canBeResolved = true
        canBeConsumed = false
        transitive = false
    }
    bundleExtractJar
    bundleExtractLibs
}

repositories {
    mavenLocal()
    maven {
        name = 'forge'
        url = 'https://maven.neoforged.net/releases'
    }
    maven {
        name = 'mojang meta'
        url = 'https://maven.neoforged.net/mojang-meta/'
        content {
            includeModule('net.neoforged', 'minecraft-dependencies')
        }
    }
    for (tool in TOOLS) {
        if (tool.repo) {
            maven {
                name = tool.name
                url = tool.repo
            }
        }
    }
}

dependencies {
    def tool = { configuration, config ->
      if (config.classpath) {
        for (def version : config.classpath) {
          add(configuration, version, {
            transitive = false
          })
        }
      } else {
        add(configuration, config.version, {
          transitive = false
        })
      }
    }
    srgutilsJar "net.neoforged:srgutils:${SRGUTILS_VERSION}"
    tool("fernflower", FERNFLOWER)
    tool("mergetool", MERGETOOL)
    tool("bundleExtractJar", BUNDLE_EXTRACT_JAR)
    tool("bundleExtractLibs", BUNDLE_EXTRACT_LIBS)
    nfrt "net.neoforged:neoform-runtime:1.0.4:all"
}

def versionJson = file(PATH_CACHED_VERSION + 'version.json')
def versionJsonTask
if (CONFIG.containsKey("version_zip")) {
    task downloadZip(type: Download) {
        src CONFIG.version_zip
        dest file(PATH_CACHED_VERSION + 'version.zip')
        useETag 'all'
        onlyIfModified true
        quiet true
    }
    versionJsonTask = task extractJson(dependsOn: downloadZip) {
        def zip = zipTree(downloadZip.dest)
        inputs.files zip
        outputs.file versionJson
        doLast {
            def path = versionJson.toPath()
            Files.deleteIfExists(path)
            Files.copy(zip.singleFile.toPath(), path)
        }
    }
} else {
    versionJsonTask = task downloadJson(type: Download, dependsOn: rootProject.downloadVersionManifest) {
        def manifest = rootProject.downloadVersionManifest.dest
        inputs.file manifest
        def id = version
        src { 
            Utils.init()
            manifest.json.versions.find{ it.id == id }.url
        }
        dest versionJson
        useETag 'all'
        onlyIfModified true
        quiet true
    }
}
['client', 'server'].each { id ->
    def name = 'download' + id.replace('_m', 'M').capitalize()
    task "${name}"(type: Download, dependsOn: versionJsonTask) {
        def json = versionJson
        inputs.file json
        src { json.json.downloads.get(id).url }
        dest file(PATH_CACHED_VERSION + id + (id.contains('_') ? '.txt' : '.jar'))
        useETag 'all'
        onlyIfModified true
        quiet true
    }
}

task downloadLibraries(type: DownloadLibraries, dependsOn: versionJsonTask) {
    json = versionJson
    config = CONFIG
    dest = new File(gradle.gradleUserHomeDir, '/caches/neoform/libraries/')
}
task downloadAssets(type: DownloadAssets) {
    assetJson = file(PATH_CACHED_VERSION + 'assets.json')
    nfrt = configurations.nfrt
    minecraftVersion = version
}

task createAssetsDataJar(type: Jar, dependsOn: downloadAssets) {
    from downloadAssets.assetJson
    destinationDirectory = file(PATH_CACHED_VERSION)
    archiveFileName = 'assets.json.jar'
}

task extractServer(type: ExtractBundleJar, dependsOn: [downloadServer]) {
    config BUNDLE_EXTRACT_JAR, configurations.bundleExtractJar
    input = downloadServer.dest
    dest = file(PATH_CACHED_VERSION + 'server.extracted.jar')
}
task extractServerLibraries(type: ExtractBundleLibs, dependsOn: [downloadServer]) {
    config BUNDLE_EXTRACT_LIBS, configurations.bundleExtractLibs
    input = downloadServer.dest
    dest = file(PATH_CACHED_VERSION + 'server_libraries')
}

task filterClient(type: SplitJar, dependsOn: [downloadClient]) {
    source = downloadClient.dest
    slim = file(PATH_CACHED_VERSION + 'client.slim.jar')
    extra = file(PATH_CACHED_VERSION + 'client.extra.jar')
}

task filterServer(type: SplitJar, dependsOn: [extractServer]) {
    source = extractServer.dest
    slim = file(PATH_CACHED_VERSION + 'server.slim.jar')
    extra = file(PATH_CACHED_VERSION + 'server.extra.jar')
}

task mergeJars(type: MergeJar, dependsOn: [downloadClient, downloadServer]) {
    config MERGETOOL, configurations.mergetool
    client = downloadClient.dest
    server = downloadServer.dest
    dest = file(PATH_CACHED_VERSION + 'joined.jar')
}

task filterJoined(type: SplitJar, dependsOn: [mergeJars]) {
    source = mergeJars.dest
    slim = file(PATH_CACHED_VERSION + 'joined.slim.jar')
    extra = file(PATH_CACHED_VERSION + 'joined.extra.jar')
}

def mappingsFile = null

def sides = [
    client: [Name: 'Client', jsonlibs: true,  extra: 'Client', assets: true,  slim: filterClient, extra: filterClient, bundle: null],
    server: [Name: 'Server', jsonlibs: false, extra: 'Server', assets: false, slim: filterServer, extra: filterServer, bundle: downloadServer],
    joined: [Name: 'Joined', jsonlibs: true,  extra: 'Client', assets: true,  slim: filterJoined, extra: filterJoined, bundle: null]
]

sides.each{ s, child ->
    child.libraries = task "fernflowerLibraries${child.Name}"(type: CreateFernflowerLibraries, dependsOn: [downloadLibraries, versionJsonTask, child.slim] + (BUNDLE_EXTRACT_LIBS == null ? [] : [extractServerLibraries])) {
        meta = versionJson
        config = CONFIG
        side = s
        root = downloadLibraries.dest
        if ('server'.equals(s)) {
            extras.from(files(filterServer.extra))
            if (BUNDLE_EXTRACT_LIBS != null) {
                extras.from(extractServerLibraries.dest.map { Files.walk(it.getAsFile().toPath()).filter { Files.isRegularFile(it) }.collect(Collectors.toList()) } )
            }
        }
        dest = file(PATH_CACHED_VERSION + s + '.fernflower.libs.txt')
    }
    child.predecompile = child.slim.slim
}

task projectRoot(type: Copy) {
    from rootProject.file('templates/root_settings.gradle')
    into file('projects/')
    rename { 'settings.gradle' }
    expand([version: project.name])
}

task extractNatives(type: ExtractNatives, dependsOn: [versionJsonTask, downloadLibraries]) {
    meta = versionJson
    cache = downloadLibraries.dest
    dest = file(PATH_NATIVES)
}

task decompileAll
task projectAll
task projectDeleteAll
task projectResetAll
task projectApplyAll
task projectMakeAll

task testDecompile
task testCompile
//task testApi
task testJdks(dependsOn:[testDecompile, testCompile/*, testApi*/])

sides.each{ side, child ->
    // Normal workflow tasks
    child.decompile = task "decompile${child.Name}"(type: FernflowerTask, dependsOn: [/*verify,*/ child.libraries]) {
        config FERNFLOWER, configurations.fernflower
        classpath = configurations.fernflower
        libraries = child.libraries.dest
        input = child.predecompile
        log = file(PATH_CACHED_VERSION + side + '.decompile.log')
        dest = file(PATH_CACHED_VERSION + side + '.decompile.jar')
        
    }
    decompileAll.dependsOn(child.decompile)
    
    child.pkgs = task "create${child.Name}PackageInfos"(type: MakePackageInfos, dependsOn: child.decompile) {
        input = child.decompile.dest
        template = PATH_INJECT_TEMPLATE.exists() ? PATH_INJECT_TEMPLATE : null
        dest = file(PATH_CACHED_VERSION + side + '.pkgs.jar')
    }
}

task deduplicateSources(type: DeduplicateJars, dependsOn: [sides.client.decompile, sides.server.decompile, sides.joined.decompile]) {
    clientIn = sides.client.decompile.dest
    serverIn = sides.server.decompile.dest
    joinedIn = sides.joined.decompile.dest
    duplicates = file(PATH_CACHED_VERSION + 'source.duplicates.jar')
    sides.client.slimsrc = clientOut = file(PATH_CACHED_VERSION + 'client.decompile.slim.jar')
    sides.server.slimsrc = serverOut = file(PATH_CACHED_VERSION + 'server.decompile.slim.jar')
    sides.joined.slimsrc = joinedOut = file(PATH_CACHED_VERSION + 'joined.decompile.slim.jar')
}

task projectSharedApplyPatches(type: ApplyPatches, dependsOn: [deduplicateSources, projectRoot]) {
    baseZip = deduplicateSources.duplicates
    output = project.file('projects/shared')
    patches = project.file('patches/shared')
}
task projectSharedMakePatches(type: MakePatches, dependsOn: [deduplicateSources, projectRoot]) {
    mustRunAfter projectSharedApplyPatches
    baseZip = deduplicateSources.duplicates
    modified = project.file('projects/shared')
    patches = project.file('patches/shared')
}
task projectSharedReset(type: Copy, dependsOn: [deduplicateSources, projectRoot]) {
    from zipTree(deduplicateSources.duplicates)
    into project.file('projects/shared')
}

sides.each{ side, child ->
    def project_dir = project.file("projects/${side}")
    def patches_dir = project.file("patches/${side}")
    
    child.delete = task "project${child.Name}Delete"(type: Delete) {
        delete project_dir
    }
    projectDeleteAll.dependsOn(child.delete)
    
    child.project = task "project${child.Name}"(type: CreateProjectTemplate, dependsOn: [projectRoot, child.extra, child.decompile, child.pkgs] +
            (child.jsonlibs ? [versionJsonTask, extractNatives] : []) +
            (child.assets ? [createAssetsDataJar] : []) +
            (child.bundle != null ? [child.bundle] : [])
    ) {
        mustRunAfter child.delete
        dest = project_dir
        distro = side
        template = rootProject.file('templates/build.gradle')
        if (child.jsonlibs)
            meta = versionJson
        if (child.bundle != null)
            bundle = child.bundle.dest
        CONFIG?.libraries?.get(side)?.each { library "'${it}'" }
        version = project.name
        libraryFile child.extra.extra.get().getAsFile()
        if (child.assets) {
            libraryFile createAssetsDataJar.archiveFile.get().asFile
            assetJsonFile = downloadAssets.assetJson
        }
        replace '{java_target}', JAVA_TARGET + ''
        replaceFile '{inject}', PATH_INJECT
        replaceFile '{natives}', child.jsonlibs ? extractNatives.dest : null
        replaceFile '{merged_src}', project.file('projects/shared')
    }
    projectAll.dependsOn(child.project)

    child.resetPkgs = task "project${child.Name}ResetPackages"(type: Copy, dependsOn: [child.pkgs, child.project]) {
        from zipTree(child.pkgs.dest)
        into new File(project_dir, 'src/pkginfo/java')
    }

    child.reset = task "project${child.Name}Reset"(type: Copy, dependsOn: [child.resetPkgs, child.project, child.decompile, projectSharedReset]) {
        mustRunAfter child.project
        from zipTree(child.slimsrc)
        into new File(project_dir, 'src/main/java')
    }
    projectResetAll.dependsOn(child.reset)
    
    child.makePatchesDir = task "project${child.Name}MakePatchesDir"(type: MakeDir) {
        folder = patches_dir
    }
    child.apply = task "project${child.Name}ApplyPatches"(type: ApplyPatches, dependsOn: [child.resetPkgs, child.project, child.decompile, child.makePatchesDir, projectSharedApplyPatches]) {
        baseZip = child.slimsrc
        output = new File(project_dir, 'src/main/java')
        patches = patches_dir
    }
    projectApplyAll.dependsOn(child.apply)

    child.makePatches = task "project${child.Name}MakePatches"(type: MakePatches, dependsOn: [projectRoot, child.project, deduplicateSources, projectSharedMakePatches]) {
        mustRunAfter child.apply
        baseZip = child.slimsrc
        modified = new File(project_dir, 'src/main/java')
        patches = patches_dir
    }
    projectMakeAll.dependsOn child.makePatches
    
    // Tests
    def testDecompileSide = task("testDecompile${child.Name}")
    testDecompile.dependsOn(testDecompileSide)
    def testCompileSide = task("testCompile${child.Name}")
    testCompile.dependsOn(testCompileSide)
    /*
    def testApiSide = task("testApi${child.Name}")
    testApi.dependsOn(testApiSide)
    */
    
    def jdks = [
        [name: 'hotspot8',   Name: 'HotSpot8',   version: 8],
        [name: 'hotspot11',  Name: 'HotSpot11',  version: 11],
        [name: 'hotspot15',  Name: 'HotSpot15',  version: 15],
        [name: 'hotspot16',  Name: 'HotSpot16',  version: 16],
        [name: 'hotspot17',  Name: 'HotSpot17',  version: 17],
        [name: 'hotspot18',  Name: 'HotSpot18',  version: 18],
        [name: 'hotspot19',  Name: 'HotSpot19',  version: 19],
        [name: 'hotspot20',  Name: 'HotSpot20',  version: 20],
        [name: 'hotspot21',  Name: 'HotSpot21',  version: 21],
        [name: 'hotspot22',  Name: 'HotSpot22',  version: 22],
        [name: 'hotspot23',  Name: 'HotSpot23',  version: 23],
        [name: 'hotspot24',  Name: 'HotSpot24',  version: 24],
        [name: 'hotspot25',  Name: 'HotSpot25',  version: 25]
    ]
    jdks.findAll{ it.version >= JAVA_TARGET }.each{ jdk ->
        def testPath = project.file(PATH_CACHED_VERSION + 'test/' + side + '-' + jdk.name + '/')
        
        def tstDecompile = task "testDecompile${child.Name}${jdk.Name}"(type: FernflowerTask, dependsOn: [child.libraries]) {
            config FERNFLOWER, configurations.fernflower
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(jdk.version)
            }
            libraries = child.libraries.dest
            input = child.predecompile
            log = new File(testPath, side + '.decompile.log')
            dest = new File(testPath, side + '.decompile.jar')
            
        }
        def tstDecompileCheck = task "testDecompile${child.Name}${jdk.Name}Compare"(type: CompareJars, dependsOn: [tstDecompile, child.decompile]) {
            expected = child.decompile.dest
            actual = tstDecompile.dest
        }
        testDecompileSide.dependsOn(tstDecompileCheck)
        
        def tstCompileClean = task "testCompile${child.Name}${jdk.Name}Clean"(type: Delete) {
            delete new File(testPath, 'classes')
        }
        
        def sourceDir = child.apply.output
        def sharedDir = projectSharedApplyPatches.output
        
        def tstCompile = task "testCompile${child.Name}${jdk.Name}"(type: JavaCompile, dependsOn: [child.apply, tstCompileClean] + (jdk.official ? [child.renameSources] : [])) {
            javaCompiler = javaToolchains.compilerFor {
                languageVersion = JavaLanguageVersion.of(jdk.version)
            }
            source = project.files(sourceDir)
            if (sharedDir != null)
                source += project.files(sharedDir)
            destinationDirectory = new File(testPath, 'classes')
            options.warnings = false
            options.encoding = ENCODING
            options.forkOptions.jvmArgs += '-Xmx1g'
            sourceCompatibility = targetCompatibility = JAVA_TARGET <= 8 ? '1.' + JAVA_TARGET : JAVA_TARGET.toString()
            // JavaCompile task type requires classpath to be specified before the task begins execution
            // but the data isn't generated yet, so instead - inject the classpath as the first thing done when it begins
            classpath = files()
            classpath.from child.libraries.dest.map { java.nio.file.Files.readAllLines(it.getAsFile().toPath()).collect { new File(it.substring(3)) }} // skip "-e="
            getOptions().setFork(true)
        }
        testCompileSide.dependsOn(tstCompile)
        
        /*
        def tstApi = task "testApi${child.Name}${jdk.Name}"(type: CheckAPI, dependsOn: [tstCompile, rootProject.extractRuntimeApi]) {
            input = tstCompile.destinationDir
            //apis.add(rootProject.extractRuntimeApi.dest)
            dest new File(testPath, 'api_errors.json')
        }
        testApiSide.dependsOn(tstApi)
        */
    }
}

task generateConfiguration(type: SingleFileOutput) {
    inputs.property('config', CONFIG)
    inputs.property('version', version)
    inputs.property('fernflower', FERNFLOWER)
    inputs.property('mergetool', MERGETOOL)
    inputs.property('bundle_extract_jar', BUNDLE_EXTRACT_JAR)
    inputs.property('java_target', JAVA_TARGET)
    inputs.property('encoding', ENCODING)
    dest = file(PATH_CACHED_VERSION_DATA + 'config.json')

    doLast {
        def json = new groovy.json.JsonBuilder()
        def config = inputs.properties.config

        def steps_def = [
            joined: [
                [type: 'downloadManifest'],
                [type: 'downloadJson'],
                [type: 'downloadClient', json: '{downloadJsonOutput}'],
                [type: 'downloadServer', json: '{downloadJsonOutput}'],
                [type: 'merge', client: '{downloadClientOutput}', server: '{downloadServerOutput}'],
                [type: 'strip', input: '{mergeOutput}'],
                [type: 'listLibraries'],
                [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{stripOutput}'],
                [type: 'inject', input: '{decompileOutput}'],
                [type: 'patch', input: '{injectOutput}']
            ],
            client: [
                [type: 'downloadManifest'],
                [type: 'downloadJson'],
                [type: 'downloadClient', json: '{downloadJsonOutput}'],
                [type: 'strip', input: '{downloadClientOutput}'],
                [type: 'listLibraries'],
                [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{stripOutput}'],
                [type: 'inject', input: '{decompileOutput}'],
                [type: 'patch', input: '{injectOutput}']
            ],
            server: [
                [type: 'downloadManifest'],
                [type: 'downloadJson'],
                [type: 'downloadServer', json: '{downloadJsonOutput}'],
                [type: 'bundleExtractJar', name: 'extractServer', input: '{downloadServerOutput}'],
                [type: 'strip', input: '{extractServerOutput}'],
                [type: 'listLibraries', bundle: '{downloadServerOutput}'],
                [type: 'decompile', libraries: '{listLibrariesOutput}', input: '{stripOutput}'],
                [type: 'inject', input: '{decompileOutput}'],
                [type: 'patch', input: '{injectOutput}']
            ]
        ]
        def functions_def = [
            decompile: inputs.properties.fernflower.findAll {it.key != 'path'},
            merge:     inputs.properties.mergetool.findAll {it.key != 'path'},
            bundleExtractJar: inputs.properties.bundle_extract_jar.findAll {it.key != 'path'}
        ]
        def specVer = 5
        
        if (config.containsKey('version_zip')) {
            for (def side : steps_def.values()) {
                side.removeAll { 'downloadManifest'.equals(it.type) }
                side.find { 'downloadJson'.equals(it.type) }['version_zip'] = config.version_zip
            }
        }
        
        json {
            spec specVer
            version inputs.properties.version
            official config.official
            java_target inputs.properties.java_target
            encoding inputs.properties.encoding
            data {
                inject 'config/inject/'
                patches {
                    client 'patches/client/'
                    joined 'patches/joined/'
                    server 'patches/server/'
                }
            }
            steps steps_def
            functions functions_def
            libraries config.libraries
        }

        dest.get().getAsFile().text = groovy.json.JsonOutput.prettyPrint(json.toString())
    }
}

def makeZip = tasks.register('makeZip', Zip) {
    dependsOn generateConfiguration
    archiveBaseName = rootProject.name
    archiveVersion = project.version
    destinationDirectory = file(PATH_BUILD + '/distributions')

    from generateConfiguration

    def patches = file('patches')
    if (patches.exists()) {
        def shared = file('patches/shared')
        for (def side : ['client', 'server', 'joined']) {
            from(file('patches/' + side)) {
                into 'patches/' + side
            }
            from(shared) {
                into 'patches/' + side
            }
        }
    }

    if (PATH_INJECT != null && PATH_INJECT.exists()) {
        from(PATH_INJECT) {
            into 'config/inject/'
        }
    }
}

// This uses advzip: https://linux.die.net/man/1/advzip
def optimizeZip = tasks.register('optimizeZip', Exec) {
    dependsOn makeZip
    description = "Optimizes the NeoForm ZIP-file in-place"
    commandLine "advzip", "--recompress", "-k", "-4"
    argumentProviders.add(
            objects.newInstance(ZipPathArgumentProvider).tap {
                file = makeZip.flatMap(AbstractArchiveTask::getArchiveFile)
            }
    )
}
if (optimize_zip.toBoolean()) {
    makeZip.configure { finalizedBy optimizeZip }
}

def componentMaker = objects.newInstance(ComponentMaker)
def neoformComponent = componentMaker.componentFactory.adhoc('neoform')
components.add(neoformComponent)
def mappingFormatAttr = Attribute.of('net.neoforged.symbol-mappings-format', String)

configurations {
    neoformData {
        canBeResolved = false
        attributes {
            attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, JAVA_TARGET)
        }
        outgoing {
            capability "net.neoforged:neoform:${project.version + '-' + rootProject.TIMESTAMP}"
        }
        neoformComponent.addVariantsFromConfiguration(it) {}
    }
    neoformLibraries {
        canBeResolved = false
    }
    neoformRuntimeElements {
        canBeResolved = false
        attributes {
            attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, JAVA_TARGET)
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
        outgoing {
            capability "net.neoforged:neoform-dependencies:${project.version + '-' + rootProject.TIMESTAMP}"
        }
        neoformComponent.addVariantsFromConfiguration(it) {}
        extendsFrom neoformLibraries
    }
    neoformApiElements {
        canBeResolved = false
        attributes {
            attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, JAVA_TARGET)
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_API))
        }
        outgoing {
            capability "net.neoforged:neoform-dependencies:${project.version + '-' + rootProject.TIMESTAMP}"
        }
        neoformComponent.addVariantsFromConfiguration(it) {}
        extendsFrom neoformLibraries
    }
    parameterMappings {
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, 'data'))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, 'symbol-mappings'))
            attribute(mappingFormatAttr, 'tsrg2-lzma')
        }
        outgoing {
            capability "net.neoforged:neoform-parameter-mappings:${project.version + '-' + rootProject.TIMESTAMP}"
        }
        neoformComponent.addVariantsFromConfiguration(it) {}
    }
}

artifacts {
    neoformData makeZip
}

TOOLS.each {
    dependencies.add('neoformData', it.version) { transitive = false }
}

['server', 'client', 'joined'].each {
    CONFIG?.libraries?.get(it)?.each { dependencies.add('neoformApiElements', it) { transitive = false } }
}

dependencies {
    neoformLibraries("net.neoforged:minecraft-dependencies:${project.version}") {
        endorseStrictVersions()
    }
}

publishing {
    publications {
        timed(MavenPublication) {
            artifactId = rootProject.name
            version = project.version + '-' + rootProject.TIMESTAMP
            from components.neoform
            pom {
                name = 'NeoForm'
                description = 'Configuration files used for deobfuscating and modding Minecraft.'
                url = 'https://github.com/NeoForged/NeoForm'
                scm {
                    url = 'https://github.com/NeoForged/NeoForm'
                    connection = 'scm:git:git://github.com/NeoForged/NeoForm.git'
                    developerConnection = 'scm:git:git@github.com:NeoForged/NeoForm.git'
                }
                issueManagement {
                    system = 'github'
                    url = 'https://github.com/NeoForged/NeoForm/issues'
                }

                licenses {
                    license {
                        name = 'All Rights Reserved, No redistribution.'
                        url = ''
                    }
                }
            }
        }
    }
    repositories {
        maven {
            if (rootProject.hasProperty('MAVEN_USER') && rootProject.hasProperty('MAVEN_PASSWORD') && rootProject.hasProperty('MAVEN_URL')) {
                url = rootProject.getProperty('MAVEN_URL')
                authentication {
                    basic(BasicAuthentication)
                }
                credentials {
                    username = rootProject.getProperty('MAVEN_USER') ?: 'not'
                    password = rootProject.getProperty('MAVEN_PASSWORD') ?: 'set'
                }
            } else {
                url = rootProject.file('repo').getAbsoluteFile().toURI().toString()
            }
        }
    }
}