name: Check For New Minecraft Version
on:
  # This is triggered by n8n after a new Minecraft version has been detected
  workflow_dispatch:
    inputs:
      publish:
        description: 'Auto Publish'
        required: false
        default: true
        type: boolean

concurrency:
  group: check-for-updates

permissions:
  actions: write # Needed to trigger the update workflow

jobs:
  # This job will run a Gradle task to check for a new version
  check:
    name: Check for new versions
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Java 21
        uses: neoforged/actions/setup-java@main
        with:
          java-version: 21
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v5
      # This job will create outputs:
      # - release_type ('special' for anything that's not mainline)
      # - latest_version
      # - current_version
      - id: check_for_update
        name: Check for Minecraft Updates
        run: ./gradlew :checkForMinecraftUpdate
      - id: postprocess
        name: Post-Process Update Variables
        uses: actions/github-script@v8
        env:
          LATEST_VERSION: ${{ steps.check_for_update.outputs.latest_version }}
          CURRENT_VERSION: ${{ steps.check_for_update.outputs.current_version }}
          RELEASE_TYPE: ${{ steps.check_for_update.outputs.release_type }}
        with:
          script: |
            const fs = require('fs');
            const currentVersion = process.env.CURRENT_VERSION;
            const latestVersion = process.env.LATEST_VERSION;
            const releaseType = process.env.RELEASE_TYPE;
            
            if (currentVersion === latestVersion) {
              console.log('No new version has been released.');
              return;
            }
            
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `new_version=${latestVersion}\n`, 'utf8');
            
            // if we're on the default branch, create a new branch for special releases
            // otherwise just stay on the same branch.
            const defaultRef = 'refs/heads/' + context.payload.repository.default_branch;
            const currentRef = context.ref;
            console.log('Default ref: %s. Current ref: %s', defaultRef, currentRef); 
            const isDefaultRef = currentRef === defaultRef;
            
            if (isDefaultRef && releaseType === 'special') {
              console.log('Using new branch for special release found on default branch: %s', releaseType);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `new_branch=${releaseType}/${latestVersion}\n`, 'utf8');
            }

      - name: Trigger Update Workflow
        if: ${{ always() && !cancelled() && !failure() && needs.check.result == 'success' && needs.check.outputs.new_version }}
        uses: actions/github-script@v8
        # We need to use environment variables here to avoid untrusted input injection into the javascript code below.
        env:
          COMMIT_REF: ${{ github.ref }}
          NEW_VERSION: ${{ steps.postprocess.outputs.new_version }}
          NEW_BRANCH: ${{ steps.postprocess.outputs.new_branch }}
          PUBLISH: ${{ inputs.publish }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'update.yml',
              ref: process.env.COMMIT_REF,
              inputs: {
                'new_version': process.env.NEW_VERSION,
                'new_branch': process.env.NEW_BRANCH,
                'publish': process.env.PUBLISH,
              }
            });
