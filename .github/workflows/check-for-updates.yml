name: Check For New Minecraft Version
on:
  # This is triggered by n8n after a new Minecraft version has been detected
  workflow_dispatch:
    inputs:
      publish:
        description: 'Auto Publish'
        required: false
        default: true
        type: boolean

concurrency:
  group: check-for-updates

permissions:
  actions: write
  contents: write
  statuses: write

jobs:
  # This job will run a Gradle task to check for a new version
  check:
    name: Check for new versions
    runs-on: ubuntu-latest
    outputs:
      new_branch: ${{ steps.postprocess.outputs.new_branch }}
      new_version: ${{ steps.postprocess.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
      - name: Setup Java 21
        uses: neoforged/actions/setup-java@main
        with:
          java-version: 21
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v5
      # This job will create outputs:
      # - release_type ('special' for anything that's not mainline)
      # - latest_version
      # - current_version
      - id: check_for_update
        name: Check for Minecraft Updates
        run: ./gradlew :checkForMinecraftUpdate
      - id: postprocess
        name: Post-Process Update Variables
        uses: actions/github-script@v8
        env:
          LATEST_VERSION: ${{ steps.check_for_update.outputs.latest_version }}
          CURRENT_VERSION: ${{ steps.check_for_update.outputs.current_version }}
          RELEASE_TYPE: ${{ steps.check_for_update.outputs.release_type }}
        with:
          script: |
            const fs = require('fs');
            const currentVersion = process.env.CURRENT_VERSION;
            const latestVersion = process.env.LATEST_VERSION;
            const releaseType = process.env.RELEASE_TYPE;
            
            if (currentVersion === latestVersion) {
              console.log('No new version has been released.');
              return;
            }
            
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `new_version=${latestVersion}\n`, 'utf8');
            
            // if we're on the default branch, create a new branch for special releases
            // otherwise just stay on the same branch.
            const defaultRef = 'refs/heads/' + context.payload.repository.default_branch;
            const currentRef = context.ref;
            console.log('Default ref: %s. Current ref: %s', defaultRef, currentRef); 
            const isDefaultRef = currentRef === defaultRef;
            
            if (isDefaultRef && releaseType === 'special') {
              console.log('Using new branch for special release found on default branch: %s', releaseType);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `new_branch=${releaseType}/${latestVersion}\n`, 'utf8');
            }

  run-update:
    name: Perform update
    if: ${{ always() && !cancelled() && !failure() && needs.check.result == 'success' && needs.check.outputs.new_version }}
    uses: ./.github/workflows/update.yml
    permissions:
      contents: write
    needs:
      - check
    with:
      new_version: ${{ needs.check.outputs.new_version }}
      new_branch: ${{ needs.check.outputs.new_branch }}
      publish: ${{ inputs.publish }}
    secrets: inherit
