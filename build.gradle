plugins {
    id 'de.undercouch.download'
}

import net.minecraftforge.mcpconfig.tasks.*
import net.neoforged.srgutils.MinecraftVersion

import javax.inject.Inject
import java.nio.file.Files
import java.util.function.BiFunction
import java.util.stream.Collectors

group = 'net.neoforged'

net.minecraftforge.mcpconfig.tasks.Utils.init()

ext {
    MC_1_16_5 = MinecraftVersion.from('1.16.5')
    VERSIONS = subprojects.collect{it.name}.sort{ a,b -> MinecraftVersion.from(a).compareTo(MinecraftVersion.from(b)) } as List
    NULL_OUTPUT = new OutputStream() { public void write(int b){} }
    TIMESTAMP = (new Date()).format('yyyyMMdd.HHmmss')
    PATH_BUILD = file('build').absolutePath

    ASM_VERSION = '9.7'
    SRGUTILS_VERSION = '1.0.10'
}

logger.lifecycle('Timestamp: ' + TIMESTAMP)

task downloadVersionManifest(type: Download) {
    src 'https://launchermeta.mojang.com/mc/game/version_manifest_v2.json'
    dest file('build/versions/version_manifest.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}

/* This check is fucked on anything > J8 because modules use a propriatary file format. We'd have to create an extracter 
 * that runs in the external process.. so fuck it.
 
task downloadRuntimeManifest(type: Download) {
    src 'https://launchermeta.mojang.com/v1/products/java-runtime/2ec0cc96c44e5a76b9c8b7c39df7210883d12871/all.json'
    dest file('build/versions/java-runtime-all.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}

task downloadRuntime(type:DownloadRuntime, dependsOn: downloadRuntimeManifest) {
    json = downloadRuntimeManifest.dest
    os = 'windows-x64'
    doFirst {
        downloadRuntimeManifest.dest.json.get('windows-x64').keySet().each{ dest.put(it, file('build/runtimes/' + it)) }
    }
}

task extractRuntimeApi(type: ExtractAPI, dependsOn: downloadRuntime) {
    doFirst {
        downloadRuntimeManifest.dest.json.get('windows-x64').keySet().each {
            roots.put(it, new File(downloadRuntime.dest.get(it), 'files'))
            apis.put(it, new File(downloadRuntime.dest.get(it), 'api.json'))
        }
    }
}
*/

if (project.hasProperty('old_version') && project.hasProperty('new_version')) {
    println('Update Old: ' + project.getProperty('old_version') + ' New: ' + project.getProperty('new_version'))
    apply from: 'update.gradle'
}

subprojects {
    ext {
        CONFIG = file('config.json').json
    }
    
    def configVersion = CONFIG.get('version', 1)
    if (configVersion == 1) {
        apply from: rootProject.file('config_versions/setup_version_1.gradle')
    } else if (configVersion == 2) {
        apply from: rootProject.file('setup_latest.gradle')
    }
}

if (System.getenv("GITHUB_ENV")) {
    task getTimestamp() {
        doLast {
            File envFile = new File(System.getenv("GITHUB_ENV"))
            if (!envFile.exists()) {
                envFile.createNewFile()
            }
            envFile.text += "GRADLE_TIMESTAMP=$TIMESTAMP\n"
        }
    }
}

def getVersionIndex(prop, default_) {
    if (!project.hasProperty(prop))
        return default_
    if (!VERSIONS.contains(project.getProperty(prop)))
        throw new IllegalArgumentException('Unknown version in ' + prop + ': ' + project.getProperty(prop) + ' Known: ' + VERSIONS.toString())
    return VERSIONS.indexOf(project.getProperty(prop))
}

def template = project(':' + VERSIONS[0])
def start = getVersionIndex('startVersion', 0)
def end = getVersionIndex('endVersion', VERSIONS.size - 1)

if (start > end)
    throw new IllegalArgumentException('Invalid start and end range: ' + VERSIONS[start] + ' > ' + VERSIONS[end])

template.tasks.each{t ->
    def myTask = project.tasks.findByName(t.name) ?: project.tasks.create(t.name)
    for (int x = start; x <= end; x++) {
        def task = project(VERSIONS[x]).tasks.findByName(t.name)
        if (task != null)
            myTask.dependsOn task
    }
}

